// Package vaultclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package vaultclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes  = "ApiKeyAuth.Scopes"
	PassetoAuthScopes = "PassetoAuth.Scopes"
)

// Defines values for FieldType.
const (
	BOOLEAN FieldType = "BOOLEAN"
	DOUBLE  FieldType = "DOUBLE"
	INTEGER FieldType = "INTEGER"
	STRING  FieldType = "STRING"
)

// Defines values for Operator.
const (
	EQ   Operator = "EQ"
	GE   Operator = "GE"
	GT   Operator = "GT"
	LE   Operator = "LE"
	LIKE Operator = "LIKE"
	LT   Operator = "LT"
	NE   Operator = "NE"
)

// Collection defines model for Collection.
type Collection struct {
	Fields      []Field `json:"fields"`
	IdFieldName string  `json:"idFieldName"`
	Indexes     []Index `json:"indexes"`
	Name        string  `json:"name"`
}

// CollectionCreateRequest defines model for CollectionCreateRequest.
type CollectionCreateRequest struct {
	Fields      *[]Field `json:"fields,omitempty"`
	IdFieldName *string  `json:"idFieldName,omitempty"`
	Indexes     *[]Index `json:"indexes,omitempty"`
}

// CollectionListResponse defines model for CollectionListResponse.
type CollectionListResponse struct {
	Collections []Collection `json:"collections"`
}

// CollectionUpdateRequest defines model for CollectionUpdateRequest.
type CollectionUpdateRequest struct {
	IdFieldName string `json:"idFieldName"`
}

// Document defines model for Document.
type Document = map[string]interface{}

// DocumentAtRevision defines model for DocumentAtRevision.
type DocumentAtRevision struct {
	Document      Document `json:"document"`
	Revision      string   `json:"revision"`
	TransactionId string   `json:"transactionId"`
}

// DocumentAuditRequest defines model for DocumentAuditRequest.
type DocumentAuditRequest struct {
	Desc    bool `json:"desc"`
	Page    int  `json:"page"`
	PerPage int  `json:"perPage"`
}

// DocumentAuditResponse defines model for DocumentAuditResponse.
type DocumentAuditResponse struct {
	Revisions []DocumentAtRevision `json:"revisions"`
}

// DocumentCountRequest defines model for DocumentCountRequest.
type DocumentCountRequest struct {
	Query *Query `json:"query,omitempty"`
}

// DocumentDiff defines model for DocumentDiff.
type DocumentDiff struct {
	Diff    map[string]interface{} `json:"diff"`
	DiffIds string                 `json:"diffIds"`
}

// DocumentDiffRequest defines model for DocumentDiffRequest.
type DocumentDiffRequest struct {
	Desc    *bool `json:"desc,omitempty"`
	Page    int   `json:"page"`
	PerPage int   `json:"perPage"`
}

// DocumentDiffResponse defines model for DocumentDiffResponse.
type DocumentDiffResponse struct {
	Diffs     []DocumentDiff       `json:"diffs"`
	Revisions []DocumentAtRevision `json:"revisions"`
}

// DocumentInsertFromFileRequest defines model for DocumentInsertFromFileRequest.
type DocumentInsertFromFileRequest struct {
	Document DocumentInsertFromFileRequest_Document `json:"document"`
}

// DocumentInsertFromFileRequestDocument0 defines model for .
type DocumentInsertFromFileRequestDocument0 = string

// DocumentInsertFromFileRequestDocument1 defines model for .
type DocumentInsertFromFileRequestDocument1 = map[string]interface{}

// DocumentInsertFromFileRequest_Document defines model for DocumentInsertFromFileRequest.Document.
type DocumentInsertFromFileRequest_Document struct {
	union json.RawMessage
}

// DocumentInsertManyFromFileRequest defines model for DocumentInsertManyFromFileRequest.
type DocumentInsertManyFromFileRequest struct {
	Document DocumentInsertManyFromFileRequest_Document `json:"document"`
}

// DocumentInsertManyFromFileRequestDocument0 defines model for .
type DocumentInsertManyFromFileRequestDocument0 = string

// DocumentInsertManyFromFileRequestDocument1 defines model for .
type DocumentInsertManyFromFileRequestDocument1 = map[string]interface{}

// DocumentInsertManyFromFileRequest_Document defines model for DocumentInsertManyFromFileRequest.Document.
type DocumentInsertManyFromFileRequest_Document struct {
	union json.RawMessage
}

// DocumentInsertManyRequest defines model for DocumentInsertManyRequest.
type DocumentInsertManyRequest struct {
	Documents []map[string]interface{} `json:"documents"`
}

// DocumentInsertManyResponse defines model for DocumentInsertManyResponse.
type DocumentInsertManyResponse struct {
	DocumentIds   []string `json:"documentIds"`
	TransactionId *string  `json:"transactionId,omitempty"`
}

// DocumentInsertRequest defines model for DocumentInsertRequest.
type DocumentInsertRequest = interface{}

// DocumentInsertResponse defines model for DocumentInsertResponse.
type DocumentInsertResponse struct {
	DocumentId    string  `json:"documentId"`
	TransactionId *string `json:"transactionId,omitempty"`
}

// DocumentProofRequest defines model for DocumentProofRequest.
type DocumentProofRequest struct {
	ProofSinceTransactionId *int `json:"proofSinceTransactionId,omitempty"`
	TransactionId           int  `json:"transactionId"`
}

// DocumentProofResponse defines model for DocumentProofResponse.
type DocumentProofResponse struct {
	CollectionId    int64                `json:"collectionId"`
	Database        string               `json:"database"`
	EncodedDocument []byte               `json:"encodedDocument"`
	IdFieldName     string               `json:"idFieldName"`
	VerifiableTx    SchemaVerifiableTxV2 `json:"verifiableTx"`
}

// DocumentSearchRequest defines model for DocumentSearchRequest.
type DocumentSearchRequest struct {
	KeepOpen *bool   `json:"keepOpen,omitempty"`
	Page     int     `json:"page"`
	PerPage  int     `json:"perPage"`
	Query    *Query  `json:"query,omitempty"`
	SearchId *string `json:"searchId,omitempty"`
}

// DocumentSearchResponse defines model for DocumentSearchResponse.
type DocumentSearchResponse struct {
	Page      int                  `json:"page"`
	PerPage   int                  `json:"perPage"`
	Revisions []DocumentAtRevision `json:"revisions"`
	SearchId  string               `json:"searchId"`
}

// DocumentUpdateFromFileRequest defines model for DocumentUpdateFromFileRequest.
type DocumentUpdateFromFileRequest struct {
	Document *DocumentUpdateFromFileRequest_Document `json:"document,omitempty"`
	Query    *Query                                  `json:"query,omitempty"`
}

// DocumentUpdateFromFileRequestDocument0 defines model for .
type DocumentUpdateFromFileRequestDocument0 = string

// DocumentUpdateFromFileRequestDocument1 defines model for .
type DocumentUpdateFromFileRequestDocument1 = map[string]interface{}

// DocumentUpdateFromFileRequest_Document defines model for DocumentUpdateFromFileRequest.Document.
type DocumentUpdateFromFileRequest_Document struct {
	union json.RawMessage
}

// DocumentUpdateRequest defines model for DocumentUpdateRequest.
type DocumentUpdateRequest struct {
	Document map[string]interface{} `json:"document"`
	Query    Query                  `json:"query"`
}

// DocumentUpdateResponse defines model for DocumentUpdateResponse.
type DocumentUpdateResponse struct {
	DocumentId    string `json:"documentId"`
	Revision      string `json:"revision"`
	TransactionId string `json:"transactionId"`
}

// DocumentsCountResponse defines model for DocumentsCountResponse.
type DocumentsCountResponse struct {
	Collection string `json:"collection"`
	Count      int    `json:"count"`
}

// ErrReply defines model for ErrReply.
type ErrReply struct {
	// Code HTTP status code
	Code int `json:"code"`

	// Error Application error message, for debugging
	Error string `json:"error"`

	// Status HTTP status description
	Status string `json:"status"`
}

// ExportID defines model for ExportID.
type ExportID struct {
	Id string `json:"id"`
}

// ExportInformation defines model for ExportInformation.
type ExportInformation struct {
	Date    time.Time `json:"date"`
	Id      string    `json:"id"`
	Message string    `json:"message"`
}

// ExportS3 defines model for ExportS3.
type ExportS3 struct {
	AccessKey string `json:"accessKey"`
	Bucket    string `json:"bucket"`
	Region    string `json:"region"`
	SecretKey string `json:"secretKey"`
	Token     string `json:"token"`
	UploadKey string `json:"uploadKey"`
}

// Field defines model for Field.
type Field struct {
	Name string     `json:"name"`
	Type *FieldType `json:"type,omitempty"`
}

// FieldComparison defines model for FieldComparison.
type FieldComparison struct {
	Field    string      `json:"field"`
	Operator Operator    `json:"operator"`
	Value    interface{} `json:"value"`
}

// FieldType defines model for FieldType.
type FieldType string

// Index defines model for Index.
type Index struct {
	Fields   []string `json:"fields"`
	IsUnique bool     `json:"isUnique"`
}

// IndexCreateRequest defines model for IndexCreateRequest.
type IndexCreateRequest struct {
	Fields   []string `json:"fields"`
	IsUnique bool     `json:"isUnique"`
}

// IndexCreateResponse defines model for IndexCreateResponse.
type IndexCreateResponse = map[string]interface{}

// IndexDeleteRequest defines model for IndexDeleteRequest.
type IndexDeleteRequest struct {
	Collection string   `json:"collection"`
	Fields     []string `json:"fields"`
}

// IndexDeleteResponse defines model for IndexDeleteResponse.
type IndexDeleteResponse = map[string]interface{}

// LedgerDBSize defines model for LedgerDBSize.
type LedgerDBSize struct {
	Name string  `json:"name"`
	Size float64 `json:"size"`
}

// Operator defines model for Operator.
type Operator string

// OrderBy defines model for OrderBy.
type OrderBy struct {
	Desc  bool   `json:"desc"`
	Field string `json:"field"`
}

// PaginationRequest defines model for PaginationRequest.
type PaginationRequest struct {
	Page    int `json:"page"`
	PerPage int `json:"perPage"`
}

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	Page    int `json:"page"`
	PerPage int `json:"perPage"`
}

// Query defines model for Query.
type Query struct {
	Expressions *[]QueryExpression `json:"expressions,omitempty"`
	Limit       *int               `json:"limit,omitempty"`
	OrderBy     *[]OrderBy         `json:"orderBy,omitempty"`
}

// QueryExpression defines model for QueryExpression.
type QueryExpression struct {
	FieldComparisons *[]FieldComparison `json:"fieldComparisons,omitempty"`
}

// SchemaDualProofV2 DualProofV2 contains inclusion and consistency proofs
type SchemaDualProofV2 struct {
	// ConsistencyProof Consistency proof between Merkle Trees in the source and target transactions
	ConsistencyProof *[][]byte `json:"consistencyProof,omitempty"`

	// InclusionProof Inclusion proof of the source transaction hash in the main Merkle Tree
	InclusionProof *[][]byte `json:"inclusionProof,omitempty"`

	// SourceTxHeader Transaction header
	SourceTxHeader *SchemaTxHeader `json:"sourceTxHeader,omitempty"`

	// TargetTxHeader Transaction header
	TargetTxHeader *SchemaTxHeader `json:"targetTxHeader,omitempty"`
}

// SchemaEntry defines model for schemaEntry.
type SchemaEntry struct {
	// Expired If set to true, this entry has expired and the value is not retrieved
	Expired *bool `json:"expired,omitempty"`

	// Key Key of the target value (i.e. not the reference entry)
	Key          *[]byte           `json:"key,omitempty"`
	Metadata     *SchemaKVMetadata `json:"metadata,omitempty"`
	ReferencedBy *SchemaReference  `json:"referencedBy,omitempty"`

	// Revision Key's revision, in case of GetAt it will be 0
	Revision *string `json:"revision,omitempty"`

	// Tx Transaction id at which the target value was set (i.e. not the reference transaction id)
	Tx *string `json:"tx,omitempty"`

	// Value Value
	Value *[]byte `json:"value,omitempty"`
}

// SchemaExpiration defines model for schemaExpiration.
type SchemaExpiration struct {
	// ExpiresAt Entry expiration time (unix timestamp in seconds)
	ExpiresAt *string `json:"expiresAt,omitempty"`
}

// SchemaImmutableState defines model for schemaImmutableState.
type SchemaImmutableState struct {
	// Db The db name
	Db *string `json:"db,omitempty"`

	// PrecommittedTxHash State of the most recent precommitted transaction
	PrecommittedTxHash *[]byte `json:"precommittedTxHash,omitempty"`

	// PrecommittedTxId Id of the most recent precommitted transaction
	PrecommittedTxId *string `json:"precommittedTxId,omitempty"`

	// Signature Signature for the new state value
	Signature *SchemaSignature `json:"signature,omitempty"`

	// TxHash State of the most recent transaction
	TxHash *[]byte `json:"txHash,omitempty"`

	// TxId Id of the most recent transaction
	TxId *string `json:"txId,omitempty"`
}

// SchemaKVMetadata defines model for schemaKVMetadata.
type SchemaKVMetadata struct {
	// Deleted True if this entry denotes a logical deletion
	Deleted    *bool             `json:"deleted,omitempty"`
	Expiration *SchemaExpiration `json:"expiration,omitempty"`

	// NonIndexable If set to true, this entry will not be indexed and will only be accessed through GetAt calls
	NonIndexable *bool `json:"nonIndexable,omitempty"`
}

// SchemaReference defines model for schemaReference.
type SchemaReference struct {
	// AtTx At which transaction the key is bound, 0 if reference is not bound and should read the most recent reference
	AtTx *string `json:"atTx,omitempty"`

	// Key Reference key
	Key      *[]byte           `json:"key,omitempty"`
	Metadata *SchemaKVMetadata `json:"metadata,omitempty"`

	// Revision Revision of the reference entry
	Revision *string `json:"revision,omitempty"`

	// Tx Transaction if when the reference key was set
	Tx *string `json:"tx,omitempty"`
}

// SchemaSignature Signature for the new state value
type SchemaSignature struct {
	PublicKey *[]byte `json:"publicKey,omitempty"`
	Signature *[]byte `json:"signature,omitempty"`
}

// SchemaTx Transaction to verify
type SchemaTx struct {
	// Entries Raw entry values
	Entries *[]SchemaTxEntry `json:"entries,omitempty"`

	// Header Transaction header
	Header *SchemaTxHeader `json:"header,omitempty"`

	// KvEntries KV entries in the transaction (parsed)
	KvEntries *[]SchemaEntry `json:"kvEntries,omitempty"`

	// ZEntries Sorted Set entries in the transaction (parsed)
	ZEntries *[]SchemaZEntry `json:"zEntries,omitempty"`
}

// SchemaTxEntry defines model for schemaTxEntry.
type SchemaTxEntry struct {
	// HValue Value hash
	HValue *[]byte `json:"hValue,omitempty"`

	// Key Raw key value (contains 1-byte prefix for kind of the key)
	Key      *[]byte           `json:"key,omitempty"`
	Metadata *SchemaKVMetadata `json:"metadata,omitempty"`

	// VLen Value length
	VLen *int32 `json:"vLen,omitempty"`

	// Value Value, must be ignored when len(value) == 0 and vLen > 0,
	// otherwise sha256(value) must be equal to hValue
	Value *[]byte `json:"value,omitempty"`
}

// SchemaTxHeader Transaction header
type SchemaTxHeader struct {
	// BlRoot Binary linking tree root (Root hash of the Merkle Tree)
	BlRoot *[]byte `json:"blRoot,omitempty"`

	// BlTxId Binary linking tree transaction ID
	// (ID of last transaction already in the main Merkle Tree)
	BlTxId *string `json:"blTxId,omitempty"`

	// EH Entries Hash - cumulative hash of all entries in the transaction
	EH *[]byte `json:"eH,omitempty"`

	// Id Transaction ID
	Id *string `json:"id,omitempty"`

	// Metadata TxMetadata contains metadata set to whole transaction
	Metadata *SchemaTxMetadata `json:"metadata,omitempty"`

	// Nentries Number of entries in a transaction
	Nentries *int32 `json:"nentries,omitempty"`

	// PrevAlh State value (Accumulative Hash - Alh) of the previous transaction
	PrevAlh *[]byte `json:"prevAlh,omitempty"`

	// Ts Unix timestamp of the transaction (in seconds)
	Ts *string `json:"ts,omitempty"`

	// Version Header version
	Version *int32 `json:"version,omitempty"`
}

// SchemaTxMetadata TxMetadata contains metadata set to whole transaction
type SchemaTxMetadata struct {
	// TruncatedTxID Entry expiration information
	TruncatedTxID *string `json:"truncatedTxID,omitempty"`
}

// SchemaVerifiableTxV2 defines model for schemaVerifiableTxV2.
type SchemaVerifiableTxV2 struct {
	// DualProof DualProofV2 contains inclusion and consistency proofs
	DualProof *SchemaDualProofV2 `json:"dualProof,omitempty"`

	// Signature Signature for the new state value
	Signature *SchemaSignature `json:"signature,omitempty"`

	// Tx Transaction to verify
	Tx *SchemaTx `json:"tx,omitempty"`
}

// SchemaZEntry defines model for schemaZEntry.
type SchemaZEntry struct {
	// AtTx At which transaction the key is bound
	// 0 if reference is not bound and should read the most recent reference
	AtTx  *string      `json:"atTx,omitempty"`
	Entry *SchemaEntry `json:"entry,omitempty"`

	// Key Referenced key
	Key *[]byte `json:"key,omitempty"`

	// Score Sorted set element's score
	Score *float64 `json:"score,omitempty"`

	// Set Name of the sorted set
	Set *[]byte `json:"set,omitempty"`
}

// GetExportInformationParams defines parameters for GetExportInformation.
type GetExportInformationParams struct {
	// Id ID of export
	Id string `form:"id" json:"id"`
}

// CollectionUpdateJSONRequestBody defines body for CollectionUpdate for application/json ContentType.
type CollectionUpdateJSONRequestBody = CollectionUpdateRequest

// CollectionCreateJSONRequestBody defines body for CollectionCreate for application/json ContentType.
type CollectionCreateJSONRequestBody = CollectionCreateRequest

// UpdateDocumentJSONRequestBody defines body for UpdateDocument for application/json ContentType.
type UpdateDocumentJSONRequestBody = DocumentUpdateRequest

// UpdateDocumentMultipartRequestBody defines body for UpdateDocument for multipart/form-data ContentType.
type UpdateDocumentMultipartRequestBody = DocumentUpdateFromFileRequest

// DocumentCreateJSONRequestBody defines body for DocumentCreate for application/json ContentType.
type DocumentCreateJSONRequestBody = DocumentInsertRequest

// DocumentCreateMultipartRequestBody defines body for DocumentCreate for multipart/form-data ContentType.
type DocumentCreateMultipartRequestBody = DocumentInsertFromFileRequest

// AuditDocumentJSONRequestBody defines body for AuditDocument for application/json ContentType.
type AuditDocumentJSONRequestBody = DocumentAuditRequest

// DiffDocumentJSONRequestBody defines body for DiffDocument for application/json ContentType.
type DiffDocumentJSONRequestBody = DocumentDiffRequest

// GetDocumentProofJSONRequestBody defines body for GetDocumentProof for application/json ContentType.
type GetDocumentProofJSONRequestBody = DocumentProofRequest

// DocumentCreateManyJSONRequestBody defines body for DocumentCreateMany for application/json ContentType.
type DocumentCreateManyJSONRequestBody = DocumentInsertManyRequest

// DocumentCreateManyMultipartRequestBody defines body for DocumentCreateMany for multipart/form-data ContentType.
type DocumentCreateManyMultipartRequestBody = DocumentInsertManyFromFileRequest

// CountDocumentsJSONRequestBody defines body for CountDocuments for application/json ContentType.
type CountDocumentsJSONRequestBody = DocumentCountRequest

// SearchDocumentJSONRequestBody defines body for SearchDocument for application/json ContentType.
type SearchDocumentJSONRequestBody = DocumentSearchRequest

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody = IndexCreateRequest

// DeleteIndexJSONRequestBody defines body for DeleteIndex for application/json ContentType.
type DeleteIndexJSONRequestBody = IndexDeleteRequest

// S3ExportJSONRequestBody defines body for S3Export for application/json ContentType.
type S3ExportJSONRequestBody = ExportS3

// AsDocumentInsertFromFileRequestDocument0 returns the union data inside the DocumentInsertFromFileRequest_Document as a DocumentInsertFromFileRequestDocument0
func (t DocumentInsertFromFileRequest_Document) AsDocumentInsertFromFileRequestDocument0() (DocumentInsertFromFileRequestDocument0, error) {
	var body DocumentInsertFromFileRequestDocument0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertFromFileRequestDocument0 overwrites any union data inside the DocumentInsertFromFileRequest_Document as the provided DocumentInsertFromFileRequestDocument0
func (t *DocumentInsertFromFileRequest_Document) FromDocumentInsertFromFileRequestDocument0(v DocumentInsertFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertFromFileRequestDocument0 performs a merge with any union data inside the DocumentInsertFromFileRequest_Document, using the provided DocumentInsertFromFileRequestDocument0
func (t *DocumentInsertFromFileRequest_Document) MergeDocumentInsertFromFileRequestDocument0(v DocumentInsertFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentInsertFromFileRequestDocument1 returns the union data inside the DocumentInsertFromFileRequest_Document as a DocumentInsertFromFileRequestDocument1
func (t DocumentInsertFromFileRequest_Document) AsDocumentInsertFromFileRequestDocument1() (DocumentInsertFromFileRequestDocument1, error) {
	var body DocumentInsertFromFileRequestDocument1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertFromFileRequestDocument1 overwrites any union data inside the DocumentInsertFromFileRequest_Document as the provided DocumentInsertFromFileRequestDocument1
func (t *DocumentInsertFromFileRequest_Document) FromDocumentInsertFromFileRequestDocument1(v DocumentInsertFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertFromFileRequestDocument1 performs a merge with any union data inside the DocumentInsertFromFileRequest_Document, using the provided DocumentInsertFromFileRequestDocument1
func (t *DocumentInsertFromFileRequest_Document) MergeDocumentInsertFromFileRequestDocument1(v DocumentInsertFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentInsertFromFileRequest_Document) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentInsertFromFileRequest_Document) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDocumentInsertManyFromFileRequestDocument0 returns the union data inside the DocumentInsertManyFromFileRequest_Document as a DocumentInsertManyFromFileRequestDocument0
func (t DocumentInsertManyFromFileRequest_Document) AsDocumentInsertManyFromFileRequestDocument0() (DocumentInsertManyFromFileRequestDocument0, error) {
	var body DocumentInsertManyFromFileRequestDocument0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertManyFromFileRequestDocument0 overwrites any union data inside the DocumentInsertManyFromFileRequest_Document as the provided DocumentInsertManyFromFileRequestDocument0
func (t *DocumentInsertManyFromFileRequest_Document) FromDocumentInsertManyFromFileRequestDocument0(v DocumentInsertManyFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertManyFromFileRequestDocument0 performs a merge with any union data inside the DocumentInsertManyFromFileRequest_Document, using the provided DocumentInsertManyFromFileRequestDocument0
func (t *DocumentInsertManyFromFileRequest_Document) MergeDocumentInsertManyFromFileRequestDocument0(v DocumentInsertManyFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentInsertManyFromFileRequestDocument1 returns the union data inside the DocumentInsertManyFromFileRequest_Document as a DocumentInsertManyFromFileRequestDocument1
func (t DocumentInsertManyFromFileRequest_Document) AsDocumentInsertManyFromFileRequestDocument1() (DocumentInsertManyFromFileRequestDocument1, error) {
	var body DocumentInsertManyFromFileRequestDocument1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertManyFromFileRequestDocument1 overwrites any union data inside the DocumentInsertManyFromFileRequest_Document as the provided DocumentInsertManyFromFileRequestDocument1
func (t *DocumentInsertManyFromFileRequest_Document) FromDocumentInsertManyFromFileRequestDocument1(v DocumentInsertManyFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertManyFromFileRequestDocument1 performs a merge with any union data inside the DocumentInsertManyFromFileRequest_Document, using the provided DocumentInsertManyFromFileRequestDocument1
func (t *DocumentInsertManyFromFileRequest_Document) MergeDocumentInsertManyFromFileRequestDocument1(v DocumentInsertManyFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentInsertManyFromFileRequest_Document) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentInsertManyFromFileRequest_Document) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDocumentUpdateFromFileRequestDocument0 returns the union data inside the DocumentUpdateFromFileRequest_Document as a DocumentUpdateFromFileRequestDocument0
func (t DocumentUpdateFromFileRequest_Document) AsDocumentUpdateFromFileRequestDocument0() (DocumentUpdateFromFileRequestDocument0, error) {
	var body DocumentUpdateFromFileRequestDocument0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentUpdateFromFileRequestDocument0 overwrites any union data inside the DocumentUpdateFromFileRequest_Document as the provided DocumentUpdateFromFileRequestDocument0
func (t *DocumentUpdateFromFileRequest_Document) FromDocumentUpdateFromFileRequestDocument0(v DocumentUpdateFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentUpdateFromFileRequestDocument0 performs a merge with any union data inside the DocumentUpdateFromFileRequest_Document, using the provided DocumentUpdateFromFileRequestDocument0
func (t *DocumentUpdateFromFileRequest_Document) MergeDocumentUpdateFromFileRequestDocument0(v DocumentUpdateFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentUpdateFromFileRequestDocument1 returns the union data inside the DocumentUpdateFromFileRequest_Document as a DocumentUpdateFromFileRequestDocument1
func (t DocumentUpdateFromFileRequest_Document) AsDocumentUpdateFromFileRequestDocument1() (DocumentUpdateFromFileRequestDocument1, error) {
	var body DocumentUpdateFromFileRequestDocument1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentUpdateFromFileRequestDocument1 overwrites any union data inside the DocumentUpdateFromFileRequest_Document as the provided DocumentUpdateFromFileRequestDocument1
func (t *DocumentUpdateFromFileRequest_Document) FromDocumentUpdateFromFileRequestDocument1(v DocumentUpdateFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentUpdateFromFileRequestDocument1 performs a merge with any union data inside the DocumentUpdateFromFileRequest_Document, using the provided DocumentUpdateFromFileRequestDocument1
func (t *DocumentUpdateFromFileRequest_Document) MergeDocumentUpdateFromFileRequestDocument1(v DocumentUpdateFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentUpdateFromFileRequest_Document) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentUpdateFromFileRequest_Document) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the src-go conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the src-go, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the src-go.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the src-go URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CollectionDelete request
	CollectionDelete(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionGet request
	CollectionGet(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionUpdateWithBody request with any body
	CollectionUpdateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollectionUpdate(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionCreateWithBody request with any body
	CollectionCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollectionCreate(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDocumentWithBody request with any body
	UpdateDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDocument(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DocumentCreateWithBody request with any body
	DocumentCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DocumentCreate(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuditDocumentWithBody request with any body
	AuditDocumentWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuditDocument(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffDocumentWithBody request with any body
	DiffDocumentWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DiffDocument(ctx context.Context, ledger string, collection string, documentId string, body DiffDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDocumentProofWithBody request with any body
	GetDocumentProofWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetDocumentProof(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DocumentCreateManyWithBody request with any body
	DocumentCreateManyWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DocumentCreateMany(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDocumentsWithBody request with any body
	CountDocumentsWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CountDocuments(ctx context.Context, ledger string, collection string, body CountDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDocumentWithBody request with any body
	SearchDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDocument(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexWithBody request with any body
	CreateIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIndexWithBody request with any body
	DeleteIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteIndex(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionsList request
	CollectionsList(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// S3ExportWithBody request with any body
	S3ExportWithBody(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	S3Export(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExportInformation request
	GetExportInformation(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLedgerDbSize request
	GetLedgerDbSize(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentState request
	GetCurrentState(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CollectionDelete(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionDeleteRequest(c.Server, ledger, collection)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionGet(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionGetRequest(c.Server, ledger, collection)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionUpdateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionUpdateRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionUpdate(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionUpdateRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionCreateRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionCreate(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionCreateRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDocumentRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDocument(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDocumentRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreate(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditDocumentWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditDocumentRequestWithBody(c.Server, ledger, collection, documentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditDocument(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditDocumentRequest(c.Server, ledger, collection, documentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffDocumentWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffDocumentRequestWithBody(c.Server, ledger, collection, documentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffDocument(ctx context.Context, ledger string, collection string, documentId string, body DiffDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffDocumentRequest(c.Server, ledger, collection, documentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDocumentProofWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDocumentProofRequestWithBody(c.Server, ledger, collection, documentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDocumentProof(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDocumentProofRequest(c.Server, ledger, collection, documentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreateManyWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateManyRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreateMany(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateManyRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDocumentsWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDocumentsRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDocuments(ctx context.Context, ledger string, collection string, body CountDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDocumentsRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDocumentRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDocument(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDocumentRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndex(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionsList(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionsListRequest(c.Server, ledger)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) S3ExportWithBody(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewS3ExportRequestWithBody(c.Server, ledger, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) S3Export(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewS3ExportRequest(c.Server, ledger, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExportInformation(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExportInformationRequest(c.Server, ledger, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLedgerDbSize(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLedgerDbSizeRequest(c.Server, ledger)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentState(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentStateRequest(c.Server, ledger)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCollectionDeleteRequest generates requests for CollectionDelete
func NewCollectionDeleteRequest(server string, ledger string, collection string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionGetRequest generates requests for CollectionGet
func NewCollectionGetRequest(server string, ledger string, collection string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionUpdateRequest calls the generic CollectionUpdate builder with application/json body
func NewCollectionUpdateRequest(server string, ledger string, collection string, body CollectionUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollectionUpdateRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewCollectionUpdateRequestWithBody generates requests for CollectionUpdate with any type of body
func NewCollectionUpdateRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCollectionCreateRequest calls the generic CollectionCreate builder with application/json body
func NewCollectionCreateRequest(server string, ledger string, collection string, body CollectionCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollectionCreateRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewCollectionCreateRequestWithBody generates requests for CollectionCreate with any type of body
func NewCollectionCreateRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateDocumentRequest calls the generic UpdateDocument builder with application/json body
func NewUpdateDocumentRequest(server string, ledger string, collection string, body UpdateDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDocumentRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewUpdateDocumentRequestWithBody generates requests for UpdateDocument with any type of body
func NewUpdateDocumentRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDocumentCreateRequest calls the generic DocumentCreate builder with application/json body
func NewDocumentCreateRequest(server string, ledger string, collection string, body DocumentCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDocumentCreateRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewDocumentCreateRequestWithBody generates requests for DocumentCreate with any type of body
func NewDocumentCreateRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuditDocumentRequest calls the generic AuditDocument builder with application/json body
func NewAuditDocumentRequest(server string, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuditDocumentRequestWithBody(server, ledger, collection, documentId, "application/json", bodyReader)
}

// NewAuditDocumentRequestWithBody generates requests for AuditDocument with any type of body
func NewAuditDocumentRequestWithBody(server string, ledger string, collection string, documentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "document-id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document/%s/audit", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDiffDocumentRequest calls the generic DiffDocument builder with application/json body
func NewDiffDocumentRequest(server string, ledger string, collection string, documentId string, body DiffDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDiffDocumentRequestWithBody(server, ledger, collection, documentId, "application/json", bodyReader)
}

// NewDiffDocumentRequestWithBody generates requests for DiffDocument with any type of body
func NewDiffDocumentRequestWithBody(server string, ledger string, collection string, documentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "document-id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document/%s/audit", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDocumentProofRequest calls the generic GetDocumentProof builder with application/json body
func NewGetDocumentProofRequest(server string, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetDocumentProofRequestWithBody(server, ledger, collection, documentId, "application/json", bodyReader)
}

// NewGetDocumentProofRequestWithBody generates requests for GetDocumentProof with any type of body
func NewGetDocumentProofRequestWithBody(server string, ledger string, collection string, documentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "document-id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document/%s/proof", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDocumentCreateManyRequest calls the generic DocumentCreateMany builder with application/json body
func NewDocumentCreateManyRequest(server string, ledger string, collection string, body DocumentCreateManyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDocumentCreateManyRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewDocumentCreateManyRequestWithBody generates requests for DocumentCreateMany with any type of body
func NewDocumentCreateManyRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/documents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountDocumentsRequest calls the generic CountDocuments builder with application/json body
func NewCountDocumentsRequest(server string, ledger string, collection string, body CountDocumentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCountDocumentsRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewCountDocumentsRequestWithBody generates requests for CountDocuments with any type of body
func NewCountDocumentsRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/documents/count", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDocumentRequest calls the generic SearchDocument builder with application/json body
func NewSearchDocumentRequest(server string, ledger string, collection string, body SearchDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDocumentRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewSearchDocumentRequestWithBody generates requests for SearchDocument with any type of body
func NewSearchDocumentRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/documents/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, ledger string, collection string, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/indexes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIndexRequest calls the generic DeleteIndex builder with application/json body
func NewDeleteIndexRequest(server string, ledger string, collection string, body DeleteIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteIndexRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewDeleteIndexRequestWithBody generates requests for DeleteIndex with any type of body
func NewDeleteIndexRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/indexes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCollectionsListRequest generates requests for CollectionsList
func NewCollectionsListRequest(server string, ledger string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewS3ExportRequest calls the generic S3Export builder with application/json body
func NewS3ExportRequest(server string, ledger string, body S3ExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewS3ExportRequestWithBody(server, ledger, "application/json", bodyReader)
}

// NewS3ExportRequestWithBody generates requests for S3Export with any type of body
func NewS3ExportRequestWithBody(server string, ledger string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/export/s3", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExportInformationRequest generates requests for GetExportInformation
func NewGetExportInformationRequest(server string, ledger string, params *GetExportInformationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/export/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLedgerDbSizeRequest generates requests for GetLedgerDbSize
func NewGetLedgerDbSizeRequest(server string, ledger string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/size", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentStateRequest generates requests for GetCurrentState
func NewGetCurrentStateRequest(server string, ledger string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CollectionDeleteWithResponse request
	CollectionDeleteWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionDeleteResponse, error)

	// CollectionGetWithResponse request
	CollectionGetWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionGetResponse, error)

	// CollectionUpdateWithBodyWithResponse request with any body
	CollectionUpdateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error)

	CollectionUpdateWithResponse(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error)

	// CollectionCreateWithBodyWithResponse request with any body
	CollectionCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error)

	CollectionCreateWithResponse(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error)

	// UpdateDocumentWithBodyWithResponse request with any body
	UpdateDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error)

	UpdateDocumentWithResponse(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error)

	// DocumentCreateWithBodyWithResponse request with any body
	DocumentCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error)

	DocumentCreateWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error)

	// AuditDocumentWithBodyWithResponse request with any body
	AuditDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error)

	AuditDocumentWithResponse(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error)

	// DiffDocumentWithBodyWithResponse request with any body
	DiffDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DiffDocumentResponse, error)

	DiffDocumentWithResponse(ctx context.Context, ledger string, collection string, documentId string, body DiffDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*DiffDocumentResponse, error)

	// GetDocumentProofWithBodyWithResponse request with any body
	GetDocumentProofWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error)

	GetDocumentProofWithResponse(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error)

	// DocumentCreateManyWithBodyWithResponse request with any body
	DocumentCreateManyWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error)

	DocumentCreateManyWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error)

	// CountDocumentsWithBodyWithResponse request with any body
	CountDocumentsWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CountDocumentsResponse, error)

	CountDocumentsWithResponse(ctx context.Context, ledger string, collection string, body CountDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*CountDocumentsResponse, error)

	// SearchDocumentWithBodyWithResponse request with any body
	SearchDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error)

	SearchDocumentWithResponse(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error)

	// CreateIndexWithBodyWithResponse request with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// DeleteIndexWithBodyWithResponse request with any body
	DeleteIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	DeleteIndexWithResponse(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	// CollectionsListWithResponse request
	CollectionsListWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*CollectionsListResponse, error)

	// S3ExportWithBodyWithResponse request with any body
	S3ExportWithBodyWithResponse(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*S3ExportResponse, error)

	S3ExportWithResponse(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*S3ExportResponse, error)

	// GetExportInformationWithResponse request
	GetExportInformationWithResponse(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*GetExportInformationResponse, error)

	// GetLedgerDbSizeWithResponse request
	GetLedgerDbSizeWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*GetLedgerDbSizeResponse, error)

	// GetCurrentStateWithResponse request
	GetCurrentStateWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*GetCurrentStateResponse, error)
}

type CollectionDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentUpdateResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON409      *ErrReply
	JSON413      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r UpdateDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DocumentCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentInsertResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON413      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r DocumentCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DocumentCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuditDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentAuditResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r AuditDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuditDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentDiffResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r DiffDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDocumentProofResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentProofResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r GetDocumentProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDocumentProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DocumentCreateManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentInsertManyResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON413      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r DocumentCreateManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DocumentCreateManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDocumentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentsCountResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CountDocumentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDocumentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentSearchResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r SearchDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexCreateResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexDeleteResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r DeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionListResponse
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type S3ExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExportID
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r S3ExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r S3ExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExportInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExportInformation
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r GetExportInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExportInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLedgerDbSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LedgerDBSize
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r GetLedgerDbSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLedgerDbSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaImmutableState
	JSON400      *ErrReply
	JSON402      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r GetCurrentStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CollectionDeleteWithResponse request returning *CollectionDeleteResponse
func (c *ClientWithResponses) CollectionDeleteWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionDeleteResponse, error) {
	rsp, err := c.CollectionDelete(ctx, ledger, collection, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionDeleteResponse(rsp)
}

// CollectionGetWithResponse request returning *CollectionGetResponse
func (c *ClientWithResponses) CollectionGetWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionGetResponse, error) {
	rsp, err := c.CollectionGet(ctx, ledger, collection, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionGetResponse(rsp)
}

// CollectionUpdateWithBodyWithResponse request with arbitrary body returning *CollectionUpdateResponse
func (c *ClientWithResponses) CollectionUpdateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error) {
	rsp, err := c.CollectionUpdateWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionUpdateResponse(rsp)
}

func (c *ClientWithResponses) CollectionUpdateWithResponse(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error) {
	rsp, err := c.CollectionUpdate(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionUpdateResponse(rsp)
}

// CollectionCreateWithBodyWithResponse request with arbitrary body returning *CollectionCreateResponse
func (c *ClientWithResponses) CollectionCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error) {
	rsp, err := c.CollectionCreateWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionCreateResponse(rsp)
}

func (c *ClientWithResponses) CollectionCreateWithResponse(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error) {
	rsp, err := c.CollectionCreate(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionCreateResponse(rsp)
}

// UpdateDocumentWithBodyWithResponse request with arbitrary body returning *UpdateDocumentResponse
func (c *ClientWithResponses) UpdateDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error) {
	rsp, err := c.UpdateDocumentWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDocumentResponse(rsp)
}

func (c *ClientWithResponses) UpdateDocumentWithResponse(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error) {
	rsp, err := c.UpdateDocument(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDocumentResponse(rsp)
}

// DocumentCreateWithBodyWithResponse request with arbitrary body returning *DocumentCreateResponse
func (c *ClientWithResponses) DocumentCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error) {
	rsp, err := c.DocumentCreateWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateResponse(rsp)
}

func (c *ClientWithResponses) DocumentCreateWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error) {
	rsp, err := c.DocumentCreate(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateResponse(rsp)
}

// AuditDocumentWithBodyWithResponse request with arbitrary body returning *AuditDocumentResponse
func (c *ClientWithResponses) AuditDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error) {
	rsp, err := c.AuditDocumentWithBody(ctx, ledger, collection, documentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditDocumentResponse(rsp)
}

func (c *ClientWithResponses) AuditDocumentWithResponse(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error) {
	rsp, err := c.AuditDocument(ctx, ledger, collection, documentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditDocumentResponse(rsp)
}

// DiffDocumentWithBodyWithResponse request with arbitrary body returning *DiffDocumentResponse
func (c *ClientWithResponses) DiffDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DiffDocumentResponse, error) {
	rsp, err := c.DiffDocumentWithBody(ctx, ledger, collection, documentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffDocumentResponse(rsp)
}

func (c *ClientWithResponses) DiffDocumentWithResponse(ctx context.Context, ledger string, collection string, documentId string, body DiffDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*DiffDocumentResponse, error) {
	rsp, err := c.DiffDocument(ctx, ledger, collection, documentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffDocumentResponse(rsp)
}

// GetDocumentProofWithBodyWithResponse request with arbitrary body returning *GetDocumentProofResponse
func (c *ClientWithResponses) GetDocumentProofWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error) {
	rsp, err := c.GetDocumentProofWithBody(ctx, ledger, collection, documentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDocumentProofResponse(rsp)
}

func (c *ClientWithResponses) GetDocumentProofWithResponse(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error) {
	rsp, err := c.GetDocumentProof(ctx, ledger, collection, documentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDocumentProofResponse(rsp)
}

// DocumentCreateManyWithBodyWithResponse request with arbitrary body returning *DocumentCreateManyResponse
func (c *ClientWithResponses) DocumentCreateManyWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error) {
	rsp, err := c.DocumentCreateManyWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateManyResponse(rsp)
}

func (c *ClientWithResponses) DocumentCreateManyWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error) {
	rsp, err := c.DocumentCreateMany(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateManyResponse(rsp)
}

// CountDocumentsWithBodyWithResponse request with arbitrary body returning *CountDocumentsResponse
func (c *ClientWithResponses) CountDocumentsWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CountDocumentsResponse, error) {
	rsp, err := c.CountDocumentsWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDocumentsResponse(rsp)
}

func (c *ClientWithResponses) CountDocumentsWithResponse(ctx context.Context, ledger string, collection string, body CountDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*CountDocumentsResponse, error) {
	rsp, err := c.CountDocuments(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDocumentsResponse(rsp)
}

// SearchDocumentWithBodyWithResponse request with arbitrary body returning *SearchDocumentResponse
func (c *ClientWithResponses) SearchDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error) {
	rsp, err := c.SearchDocumentWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDocumentResponse(rsp)
}

func (c *ClientWithResponses) SearchDocumentWithResponse(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error) {
	rsp, err := c.SearchDocument(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDocumentResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// DeleteIndexWithBodyWithResponse request with arbitrary body returning *DeleteIndexResponse
func (c *ClientWithResponses) DeleteIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndexWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

func (c *ClientWithResponses) DeleteIndexWithResponse(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndex(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

// CollectionsListWithResponse request returning *CollectionsListResponse
func (c *ClientWithResponses) CollectionsListWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*CollectionsListResponse, error) {
	rsp, err := c.CollectionsList(ctx, ledger, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionsListResponse(rsp)
}

// S3ExportWithBodyWithResponse request with arbitrary body returning *S3ExportResponse
func (c *ClientWithResponses) S3ExportWithBodyWithResponse(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*S3ExportResponse, error) {
	rsp, err := c.S3ExportWithBody(ctx, ledger, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseS3ExportResponse(rsp)
}

func (c *ClientWithResponses) S3ExportWithResponse(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*S3ExportResponse, error) {
	rsp, err := c.S3Export(ctx, ledger, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseS3ExportResponse(rsp)
}

// GetExportInformationWithResponse request returning *GetExportInformationResponse
func (c *ClientWithResponses) GetExportInformationWithResponse(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*GetExportInformationResponse, error) {
	rsp, err := c.GetExportInformation(ctx, ledger, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExportInformationResponse(rsp)
}

// GetLedgerDbSizeWithResponse request returning *GetLedgerDbSizeResponse
func (c *ClientWithResponses) GetLedgerDbSizeWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*GetLedgerDbSizeResponse, error) {
	rsp, err := c.GetLedgerDbSize(ctx, ledger, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLedgerDbSizeResponse(rsp)
}

// GetCurrentStateWithResponse request returning *GetCurrentStateResponse
func (c *ClientWithResponses) GetCurrentStateWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*GetCurrentStateResponse, error) {
	rsp, err := c.GetCurrentState(ctx, ledger, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentStateResponse(rsp)
}

// ParseCollectionDeleteResponse parses an HTTP response from a CollectionDeleteWithResponse call
func ParseCollectionDeleteResponse(rsp *http.Response) (*CollectionDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionGetResponse parses an HTTP response from a CollectionGetWithResponse call
func ParseCollectionGetResponse(rsp *http.Response) (*CollectionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionUpdateResponse parses an HTTP response from a CollectionUpdateWithResponse call
func ParseCollectionUpdateResponse(rsp *http.Response) (*CollectionUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionCreateResponse parses an HTTP response from a CollectionCreateWithResponse call
func ParseCollectionCreateResponse(rsp *http.Response) (*CollectionCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDocumentResponse parses an HTTP response from a UpdateDocumentWithResponse call
func ParseUpdateDocumentResponse(rsp *http.Response) (*UpdateDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDocumentCreateResponse parses an HTTP response from a DocumentCreateWithResponse call
func ParseDocumentCreateResponse(rsp *http.Response) (*DocumentCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DocumentCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentInsertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuditDocumentResponse parses an HTTP response from a AuditDocumentWithResponse call
func ParseAuditDocumentResponse(rsp *http.Response) (*AuditDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuditDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentAuditResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDiffDocumentResponse parses an HTTP response from a DiffDocumentWithResponse call
func ParseDiffDocumentResponse(rsp *http.Response) (*DiffDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiffDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentDiffResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDocumentProofResponse parses an HTTP response from a GetDocumentProofWithResponse call
func ParseGetDocumentProofResponse(rsp *http.Response) (*GetDocumentProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDocumentProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentProofResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDocumentCreateManyResponse parses an HTTP response from a DocumentCreateManyWithResponse call
func ParseDocumentCreateManyResponse(rsp *http.Response) (*DocumentCreateManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DocumentCreateManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentInsertManyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCountDocumentsResponse parses an HTTP response from a CountDocumentsWithResponse call
func ParseCountDocumentsResponse(rsp *http.Response) (*CountDocumentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDocumentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentsCountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchDocumentResponse parses an HTTP response from a SearchDocumentWithResponse call
func ParseSearchDocumentResponse(rsp *http.Response) (*SearchDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIndexResponse parses an HTTP response from a DeleteIndexWithResponse call
func ParseDeleteIndexResponse(rsp *http.Response) (*DeleteIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionsListResponse parses an HTTP response from a CollectionsListWithResponse call
func ParseCollectionsListResponse(rsp *http.Response) (*CollectionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseS3ExportResponse parses an HTTP response from a S3ExportWithResponse call
func ParseS3ExportResponse(rsp *http.Response) (*S3ExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &S3ExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExportID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetExportInformationResponse parses an HTTP response from a GetExportInformationWithResponse call
func ParseGetExportInformationResponse(rsp *http.Response) (*GetExportInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExportInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExportInformation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLedgerDbSizeResponse parses an HTTP response from a GetLedgerDbSizeWithResponse call
func ParseGetLedgerDbSizeResponse(rsp *http.Response) (*GetLedgerDbSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLedgerDbSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LedgerDBSize
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentStateResponse parses an HTTP response from a GetCurrentStateWithResponse call
func ParseGetCurrentStateResponse(rsp *http.Response) (*GetCurrentStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaImmutableState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"FjKEjQwXl4v/DwAA//9miEo1WKYAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
